(window.webpackJsonp=window.webpackJsonp||[]).push([[211],{626:function(a,t,e){"use strict";e.r(t);var r=e(15),n=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h3",{attrs:{id:"组件中的data为什么是一个函数而不是一个对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件中的data为什么是一个函数而不是一个对象"}},[a._v("#")]),a._v(" 组件中的data为什么是一个函数而不是一个对象")]),a._v(" "),e("p",[a._v("因为如果data是一个对象则会造成数据共享，在多次使用该组件时，改变其中一个组件的值会影响全部该组件的值。而如果是通过函数的形式返回出一个对象的话，在每次使用该组件时返回出的对象的地址指向都是不一样的，这样就能让各个组件的数据独立。")]),a._v(" "),e("blockquote",[e("p",[a._v("因为对象是一种引用数据类型，在内存中只有一份。如果data的值直接是一个对象的话，那么后期组件在不同的地方多次调用的时候，会互相产生影响，因为每次调用操作data对象都是一样的。使用函数的方式返回对象，可以保证组件的每一次调用都会创建一个新对象，这样组件的每一次调用就不会相互产生影响。")])]),a._v(" "),e("blockquote",[e("p",[a._v("组件中的 data 写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果。")])]),a._v(" "),e("blockquote",[e("p",[a._v("官方答案：当一个组件被定义， data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。")]),a._v(" "),e("p",[a._v("具体原因：对象为引用类型，当重用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题")])]),a._v(" "),e("h4",{attrs:{id:"参考文章链接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考文章链接"}},[a._v("#")]),a._v(" 参考文章链接")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/190859741",target:"_blank",rel:"noopener noreferrer"}},[a._v("vue的组件中为什么data必须是一个函数？"),e("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);