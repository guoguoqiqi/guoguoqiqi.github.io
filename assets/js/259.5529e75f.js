(window.webpackJsonp=window.webpackJsonp||[]).push([[259],{675:function(e,v,_){"use strict";_.r(v);var t=_(15),s=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("blockquote",[_("p",[_("code",[e._v("Vue")]),e._v("在更新"),_("code",[e._v("DOM")]),e._v("时是异步执行的，只要侦听到数据变化，"),_("code",[e._v("Vue")]),e._v("将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更，如果同一个"),_("code",[e._v("watcher")]),e._v("被多次触发，只会被推入到队列中一次，这种在缓冲时去除重复数据对于避免不必要的计算和"),_("code",[e._v("DOM")]),e._v("操作是非常重要的，然后，在下一个的事件循环"),_("code",[e._v("tick")]),e._v("中，"),_("code",[e._v("Vue")]),e._v("刷新队列并执行实际(已去重的)工作，"),_("code",[e._v("Vue")]),e._v("在内部对异步队列尝试使用原生的"),_("code",[e._v("Promise.then")]),e._v("、"),_("code",[e._v("MutationObserver")]),e._v("和"),_("code",[e._v("setImmediate")]),e._v("，如果执行环境不支持，则会采用"),_("code",[e._v("setTimeout(fn, 0)")]),e._v("代替。")])]),e._v(" "),_("h2",{attrs:{id:"异步渲染的原因"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异步渲染的原因"}},[e._v("#")]),e._v(" 异步渲染的原因")]),e._v(" "),_("p",[e._v("对于"),_("code",[e._v("Vue")]),e._v("为何采用异步渲染，简单来说就是为了提升性能，因为不采用异步更新，在每次更新数据都会对当前组件进行重新渲染，为了性能考虑，"),_("code",[e._v("Vue")]),e._v("会在本轮数据更新后，再去异步更新视图，举个例子，让我们在一个方法内重复更新一个值。")]),e._v(" "),_("div",{staticClass:"language-js line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("this")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("msg "),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("this")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("msg "),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("this")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("msg "),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br")])]),_("p",[e._v("事实上，我们真正想要的其实只是最后一次更新而已，也就是说前三次"),_("code",[e._v("DOM")]),e._v("更新都是可以省略的，我们只需要等所有状态都修改好了之后再进行渲染就可以减少一些性能损耗。")]),e._v(" "),_("p",[e._v("对于渲染方面的问题是很明确的，最终只渲染一次肯定比修改之后即渲染所耗费的性能少，在这里我们还需要考虑一下异步更新队列的相关问题，假设我们现在是进行了相关处理使得每次更新数据只进行一次真实"),_("code",[e._v("DOM")]),e._v("渲染，来让我们考虑异步更新队列的性能优化。")]),e._v(" "),_("p",[e._v("假设这里是同步更新队列，"),_("code",[e._v("this.msg=1")]),e._v("，大致会发生这些事: "),_("code",[e._v("msg")]),e._v("值更新 "),_("code",[e._v("->")]),e._v(" 触发"),_("code",[e._v("setter")]),e._v(" "),_("code",[e._v("->")]),e._v(" 触发"),_("code",[e._v("Watcher")]),e._v("的"),_("code",[e._v("update")]),e._v(" "),_("code",[e._v("->")]),e._v(" 重新调用 "),_("code",[e._v("render")]),e._v(" "),_("code",[e._v("->")]),e._v(" 生成新的"),_("code",[e._v("vdom \\-> dom-diff \\-> dom")]),e._v("更新，这里的"),_("code",[e._v("dom")]),e._v("更新并不是渲染(即布局、绘制、合成等一系列步骤)，而是更新内存中的"),_("code",[e._v("DOM")]),e._v("树结构，之后再运行"),_("code",[e._v("this.msg=2")]),e._v("，再重复上述步骤，之后的第"),_("code",[e._v("3")]),e._v("次更新同样会触发相同的流程，等开始渲染的时候，最新的"),_("code",[e._v("DOM")]),e._v("树中确实只会存在更新完成"),_("code",[e._v("3")]),e._v("，从这里来看，前"),_("code",[e._v("2")]),e._v("次对"),_("code",[e._v("msg")]),e._v("的操作以及"),_("code",[e._v("Vue")]),e._v("内部对它的处理都是无用的操作，可以进行优化处理。")]),e._v(" "),_("p",[e._v("如果是异步更新队列，会是下面的情况，运行"),_("code",[e._v("this.msg=1")]),e._v("，并不是立即进行上面的流程，而是将对"),_("code",[e._v("msg")]),e._v("有依赖的"),_("code",[e._v("Watcher")]),e._v("都保存在队列中，该队列可能这样"),_("code",[e._v("[Watcher1, Watcher2...]")]),e._v("，当运行"),_("code",[e._v("this.msg=2")]),e._v("后，同样是将对"),_("code",[e._v("msg")]),e._v("有依赖的"),_("code",[e._v("Watcher")]),e._v("保存到队列中，"),_("code",[e._v("Vue")]),e._v("内部会做去重判断，这次操作后，可以认为队列数据没有发生变化，第"),_("code",[e._v("3")]),e._v("次更新也是上面的过程，当然，你不可能只对"),_("code",[e._v("msg")]),e._v("有操作，你可能对该组件中的另一个属性也有操作，比如"),_("code",[e._v("this.otherMsg=othermessage")]),e._v("，同样会把对"),_("code",[e._v("otherMsg")]),e._v("有依赖的"),_("code",[e._v("Watcher")]),e._v("添加到异步更新队列中，因为有重复判断操作，这个"),_("code",[e._v("Watcher")]),e._v("也只会在队列中存在一次，本次异步任务执行结束后，会进入下一个任务执行流程，其实就是遍历异步更新队列中的每一个"),_("code",[e._v("Watcher")]),e._v("，触发其"),_("code",[e._v("update")]),e._v("，然后进行重新调用"),_("code",[e._v("render")]),e._v(" "),_("code",[e._v("->")]),e._v(" "),_("code",[e._v("new vdom")]),e._v(" "),_("code",[e._v("->")]),e._v(" "),_("code",[e._v("dom-diff")]),e._v(" "),_("code",[e._v("->")]),e._v(" "),_("code",[e._v("dom")]),e._v("更新等流程，但是这种方式和同步更新队列相比，不管操作多少次"),_("code",[e._v("msg")]),e._v("， "),_("code",[e._v("Vue")]),e._v("在内部只会进行一次重新调用真实更新流程，所以，对于异步更新队列不是节省了渲染成本，而是节省了"),_("code",[e._v("Vue")]),e._v("内部计算及"),_("code",[e._v("DOM")]),e._v("树操作的成本，不管采用哪种方式，渲染确实只有一次。")]),e._v(" "),_("p",[e._v("此外，组件内部实际使用"),_("code",[e._v("VirtualDOM")]),e._v("进行渲染，也就是说，组件内部其实是不关心哪个状态发生了变化，它只需要计算一次就可以得知哪些节点需要更新，也就是说，如果更改了"),_("code",[e._v("N")]),e._v("个状态，其实只需要发送一个信号就可以将"),_("code",[e._v("DOM")]),e._v("更新到最新，如果我们更新多个值。")]),e._v(" "),_("div",{staticClass:"language-js line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("this")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("msg "),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("this")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("age "),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("this")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("name "),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br")])]),_("p",[e._v("此处我们分三次修改了三种状态，但其实"),_("code",[e._v("Vue")]),e._v("只会渲染一次，因为"),_("code",[e._v("VIrtualDOM")]),e._v("只需要一次就可以将整个组件的"),_("code",[e._v("DOM")]),e._v("更新到最新，它根本不会关心这个更新的信号到底是从哪个具体的状态发出来的。")]),e._v(" "),_("p",[e._v("而为了达到这个目的，我们需要将渲染操作推迟到所有的状态都修改完成，为了做到这一点只需要将渲染操作推迟到本轮事件循环的最后或者下一轮事件循环，也就是说，只需要在本轮事件循环的最后，等前面更新状态的语句都执行完之后，执行一次渲染操作，它就可以无视前面各种更新状态的语法，无论前面写了多少条更新状态的语句，只在最后渲染一次就可以了。")]),e._v(" "),_("p",[e._v("将渲染推迟到本轮事件循环的最后执行渲染的时机会比推迟到下一轮快很多，所以"),_("code",[e._v("Vue")]),e._v("优先将渲染操作推迟到本轮事件循环的最后，如果执行环境不支持会降级到下一轮，"),_("code",[e._v("Vue")]),e._v("的变化侦测机制("),_("code",[e._v("setter")]),e._v(")决定了它必然会在每次状态发生变化时都会发出渲染的信号，但"),_("code",[e._v("Vue")]),e._v("会在收到信号之后检查队列中是否已经存在这个任务，保证队列中不会有重复，如果队列中不存在则将渲染操作添加到队列中，之后通过异步的方式延迟执行队列中的所有渲染的操作并清空队列，当同一轮事件循环中反复修改状态时，并不会反复向队列中添加相同的渲染操作，所以我们在使用"),_("code",[e._v("Vue")]),e._v("时，修改状态后更新"),_("code",[e._v("DOM")]),e._v("都是异步的。")]),e._v(" "),_("p",[e._v("当数据变化后会调用"),_("code",[e._v("notify")]),e._v("方法，将"),_("code",[e._v("watcher")]),e._v("遍历，调用"),_("code",[e._v("update")]),e._v("方法通知"),_("code",[e._v("watcher")]),e._v("进行更新，这时候"),_("code",[e._v("watcher")]),e._v("并不会立即去执行，在"),_("code",[e._v("update")]),e._v("中会调用"),_("code",[e._v("queueWatcher")]),e._v("方法将"),_("code",[e._v("watcher")]),e._v("放到了一个队列里，在"),_("code",[e._v("queueWatcher")]),e._v("会根据"),_("code",[e._v("watcher")]),e._v("的进行去重，若多个属性依赖一个"),_("code",[e._v("watcher")]),e._v("，则如果队列中没有该"),_("code",[e._v("watcher")]),e._v("就会将该"),_("code",[e._v("watcher")]),e._v("添加到队列中，然后便会在"),_("code",[e._v("$nextTick")]),e._v("方法的执行队列中加入一个"),_("code",[e._v("flushSchedulerQueue")]),e._v("方法(这个方法将会触发在缓冲队列的所有回调的执行)，然后将"),_("code",[e._v("$nextTick")]),e._v("方法的回调加入"),_("code",[e._v("$nextTick")]),e._v("方法中维护的执行队列，"),_("code",[e._v("flushSchedulerQueue")]),e._v("中开始会触发一个"),_("code",[e._v("before")]),e._v("的方法，其实就是"),_("code",[e._v("beforeUpdate")]),e._v("，然后"),_("code",[e._v("watcher.run")]),e._v("()才开始真正执行"),_("code",[e._v("watcher")]),e._v("，执行完页面就渲染完成，更新完成后会调用"),_("code",[e._v("updated")]),e._v("钩子。")])])}),[],!1,null,null,null);v.default=s.exports}}]);