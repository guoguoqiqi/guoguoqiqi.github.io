(window.webpackJsonp=window.webpackJsonp||[]).push([[304],{722:function(a,r,l){"use strict";l.r(r);var e=l(15),t=Object(e.a)({},(function(){var a=this,r=a.$createElement,l=a._self._c||r;return l("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[l("h3",{attrs:{id:"什么是-url-loader"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#什么是-url-loader"}},[a._v("#")]),a._v(" 什么是 url-loader")]),a._v(" "),l("p",[a._v("url-loader 会将引入的文件进行编码，生成 DataURL，相当于把文件翻译成了一串字符串，再把这个字符串打包到 JavaScript。")]),a._v(" "),l("p",[a._v("使用 base64 来加载图片也是有两面性的：")]),a._v(" "),l("ul",[l("li",[a._v("优点：节省请求，提高页面性能")]),a._v(" "),l("li",[a._v("缺点：增大本地文件大小，降低加载性能")])]),a._v(" "),l("p",[a._v("所以我们得有取舍，只对部分小 size 的图片进行 base64 编码，其它的大图片还是发请求吧。")]),a._v(" "),l("h3",{attrs:{id:"什么是-file-loader"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#什么是-file-loader"}},[a._v("#")]),a._v(" 什么是 file-loader")]),a._v(" "),l("p",[a._v("在css文件中定义background的属性或者在html中引入image的src，我们知道在webpack打包后这些图片会打包至定义好的一个文件夹下，和开发时候的相对路径会不一样，这就会导致导入图片路径的错误。而file-loader正是为了解决此类问题而产生的，他修改打包后图片的储存路径，再根据配置修改我们引用的路径，使之对应引入。")]),a._v(" "),l("h3",{attrs:{id:"两者之间的联系"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#两者之间的联系"}},[a._v("#")]),a._v(" 两者之间的联系")]),a._v(" "),l("p",[a._v("url-loader内部封装了file-loader。url-loader不依赖于file-loader，即使用url-loader时，只需要安装url-loader即可，不需要安装file-loader。")]),a._v(" "),l("h3",{attrs:{id:"总结"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),l("p",[a._v("通过上面的介绍，我们可以看到，url-loader工作分两种情况：")]),a._v(" "),l("p",[a._v("文件大小小于limit参数，url-loader将会把文件转为DataURL；\n文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader。因此我们只需要安装url-loader即可。")])])}),[],!1,null,null,null);r.default=t.exports}}]);