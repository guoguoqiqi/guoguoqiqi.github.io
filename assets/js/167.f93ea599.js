(window.webpackJsonp=window.webpackJsonp||[]).push([[167],{584:function(t,e,r){"use strict";r.r(e);var a=r(15),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:"类中成员的-public、private、protected、readonly-修饰符的理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类中成员的-public、private、protected、readonly-修饰符的理解"}},[t._v("#")]),t._v(" 类中成员的 public、private、protected、readonly 修饰符的理解")]),t._v(" "),r("ol",[r("li",[r("p",[r("strong",[t._v("public")]),t._v(" 默认修饰符，可以自由访问")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("private")]),t._v(" 当成员被标记成 private时，它就不能在声明它的类的外部访问。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("protected")]),t._v(" protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("readonly")]),t._v(" 使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。")])])]),t._v(" "),r("h4",{attrs:{id:"参考文章链接"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考文章链接"}},[t._v("#")]),t._v(" 参考文章链接")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://blog.csdn.net/weixin_33834679/article/details/89661323",target:"_blank",rel:"noopener noreferrer"}},[t._v("TypeScript基础入门 - 类 - 公共、私有与受保护的修饰符"),r("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);