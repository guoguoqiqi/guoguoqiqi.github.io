(window.webpackJsonp=window.webpackJsonp||[]).push([[186],{602:function(t,e,s){"use strict";s.r(e);var r=s(15),v=Object(r.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"vue组件通信有哪些方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue组件通信有哪些方式"}},[t._v("#")]),t._v(" Vue组件通信有哪些方式")]),t._v(" "),s("p",[t._v("组件间通信分为三种： "),s("code",[t._v("父子组件通信")]),t._v("、"),s("code",[t._v("隔代组件通信")]),t._v("、"),s("code",[t._v("兄弟组件通信")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"_1-父子组件通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-父子组件通信"}},[t._v("#")]),t._v(" 1. 父子组件通信")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("props / $emit")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("ref 与 $parent / $children")])])])]),t._v(" "),s("blockquote",[s("p",[t._v("如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例\n$parent / $children：访问父 / 子实例")])]),t._v(" "),s("h3",{attrs:{id:"_2-隔代组件通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-隔代组件通信"}},[t._v("#")]),t._v(" 2. 隔代组件通信")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("$attrs/$listeners")])])]),t._v(" "),s("blockquote",[s("p",[t._v('$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind="$attrs" 传入内部组件。通常配合 inheritAttrs 选项一起使用。')])]),t._v(" "),s("blockquote",[s("p",[t._v('$listeners：包含了父作用域中的 (不含 .native 修饰器的)  v-on 事件监听器。它可以通过 v-on="$listeners" 传入内部组件')])]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("provide / inject")])])]),t._v(" "),s("blockquote",[s("p",[t._v("祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。")])]),t._v(" "),s("h3",{attrs:{id:"_3-兄弟组件通信-下面两种方式适用于所有组件通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-兄弟组件通信-下面两种方式适用于所有组件通信"}},[t._v("#")]),t._v(" 3. 兄弟组件通信（下面两种方式适用于所有组件通信）")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("EventBus （$emit / $on）")])])]),t._v(" "),s("blockquote",[s("p",[t._v("这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。")])]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("Vuex")])])]),t._v(" "),s("blockquote",[s("p",[t._v("Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。")])]),t._v(" "),s("blockquote",[s("p",[t._v("Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n改变 store 中的状态的唯一途径就是显式地提交  (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。")])])])}),[],!1,null,null,null);e.default=v.exports}}]);