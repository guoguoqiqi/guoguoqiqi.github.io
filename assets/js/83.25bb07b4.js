(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{502:function(t,a,s){"use strict";s.r(a);var e=s(15),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div id"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"outer"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("p id"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"inner"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("Click me"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("p"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("h3",{attrs:{id:"事件冒泡"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件冒泡"}},[t._v("#")]),t._v(" 事件冒泡")]),t._v(" "),s("p",[t._v("微软提出了名为事件冒泡(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。")]),t._v(" "),s("p",[t._v("因此在事件冒泡的概念下在p元素上发生click事件的顺序应该是p -> div -> body -> html -> document")]),t._v(" "),s("h3",{attrs:{id:"事件捕获"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件捕获"}},[t._v("#")]),t._v(" 事件捕获")]),t._v(" "),s("p",[t._v("网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。")]),t._v(" "),s("p",[t._v("因此在事件捕获的概念下在p元素上发生click事件的顺序应该是document -> html -> body -> div -> p")]),t._v(" "),s("h3",{attrs:{id:"addeventlistener的第三个参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#addeventlistener的第三个参数"}},[t._v("#")]),t._v(" addEventListener的第三个参数")]),t._v(" "),s("blockquote",[s("p",[t._v("element.addEventListener(event, function, useCapture)")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("第一个参数是需要绑定的事件")])]),t._v(" "),s("li",[s("p",[t._v("第二个参数是触发事件后要执行的函数")])]),t._v(" "),s("li",[s("p",[t._v("第三个参数默认值是false，表示在事件冒泡阶段调用事件处理函数;如果参数为true，则表示在事件捕获阶段调用处理函数。")])])]),t._v(" "),s("h3",{attrs:{id:"事件代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件代理"}},[t._v("#")]),t._v(" 事件代理")]),t._v(" "),s("p",[t._v("事件代理就是运用了事件冒泡的原理。")]),t._v(" "),s("h3",{attrs:{id:"冒泡还是捕获"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#冒泡还是捕获"}},[t._v("#")]),t._v(" 冒泡还是捕获？")]),t._v(" "),s("p",[t._v("对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型。")]),t._v(" "),s("h4",{attrs:{id:"参考文章链接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考文章链接"}},[t._v("#")]),t._v(" 参考文章链接")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://segmentfault.com/a/1190000005654451",target:"_blank",rel:"noopener noreferrer"}},[t._v("JS中事件冒泡与捕获"),s("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=r.exports}}]);