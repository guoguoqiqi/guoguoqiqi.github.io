(window.webpackJsonp=window.webpackJsonp||[]).push([[558],{977:function(e,v,_){"use strict";_.r(v);var a=_(15),t=Object(a.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),_("p",[e._v("开始前先来简单看看缓存是什么，缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。我们使用 HTTP 缓存，通过复用缓存资源，减少了客户端等待时间和网络流量，同时也能缓解服务器端的压力。可以显著的提升我们网站和应用的性能。虽然 HTTP 缓存不是必须的，但重用缓存的资源通常是必要的，HTTP 缓存是一个 web 性能优化的重要手段。")]),e._v(" "),_("p",[_("img",{attrs:{src:"/images/053.png",alt:"image"}})]),e._v(" "),_("h2",{attrs:{id:"http-缓存的类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存的类型"}},[e._v("#")]),e._v(" HTTP 缓存的类型")]),e._v(" "),_("p",[e._v("通常 HTTP 缓存策略分为两种：强缓存和协商缓存。从字面意思我们可以很直观的看到它们的差别。强缓存即强制直接使用缓存。协商缓存就得和服务器协商确认下这个缓存能不能用。")]),e._v(" "),_("h3",{attrs:{id:"强缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[e._v("#")]),e._v(" 强缓存")]),e._v(" "),_("p",[e._v("强缓存不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的 network 选项中可以看到该请求返回 200 的状态码，并且"),_("code",[e._v("size")]),e._v("显示"),_("code",[e._v("from disk cache")]),e._v("或"),_("code",[e._v("from memory cache")]),e._v("；")]),e._v(" "),_("h3",{attrs:{id:"协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[e._v("#")]),e._v(" 协商缓存")]),e._v(" "),_("p",[e._v("协商缓存会先向服务器发送一个请求，服务器会根据这个请求的 request header 的一些参数来判断是否命中协商缓存，如果命中，则返回 304 状态码并带上新的 response header 通知浏览器从缓存中读取资源。")]),e._v(" "),_("h2",{attrs:{id:"http-缓存控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存控制"}},[e._v("#")]),e._v(" HTTP 缓存控制")]),e._v(" "),_("p",[e._v("在 HTTP 中，我们可以通过设置响应头以及请求头来控制缓存策略。强缓存可以通过设置"),_("code",[e._v("Expires")]),e._v("和"),_("code",[e._v("Cache-Control")]),e._v(" 两种响应头实现。如果同时存在，"),_("code",[e._v("Cache-Control")]),e._v("优先级高于"),_("code",[e._v("Expires")]),e._v("。")]),e._v(" "),_("h3",{attrs:{id:"expires"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[e._v("#")]),e._v(" Expires")]),e._v(" "),_("p",[e._v("Expires 响应头，它是 HTTP/1.0 的产物。代表该资源的过期时间，其值为一个绝对时间。它告诉浏览器在过期时间之前可以直接从浏览器缓存中存取数据。由于是个绝对时间，客户端与服务端的时间时差或误差等因素可能造成客户端与服务端的时间不一致，将导致缓存命中的误差。如果在"),_("code",[e._v("Cache-Control")]),e._v("响应头设置了 "),_("code",[e._v("max-age")]),e._v(" 或者 "),_("code",[e._v("s-max-age")]),e._v(" 指令，那么 "),_("code",[e._v("Expires")]),e._v(" 会被忽略。")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("Expires: Wed, 21 Oct 2015 07:28:00 GMT\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br")])]),_("h3",{attrs:{id:"cache-control"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[e._v("#")]),e._v(" Cache-Control")]),e._v(" "),_("p",[_("code",[e._v("Cache-Control")]),e._v(" 出现于 HTTP/1.1。可以通过指定多个指令来实现缓存机制。主要用表示资源缓存的最大有效时间。即在该时间端内，客户端不需要向服务器发送请求。优先级高于 Expires。其过期时间指令的值是相对时间，它解决了绝对时间的带来的问题。")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("Cache-Control: max-age=315360000\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br")])]),_("p",[_("code",[e._v("Cache-Control")]),e._v(" 有很多属性，不同的属性代表的意义也不同。"),_("strong",[e._v("可缓存性")])]),e._v(" "),_("ul",[_("li",[_("code",[e._v("public")]),e._v(" 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。")]),e._v(" "),_("li",[_("code",[e._v("private")]),e._v(" 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）")]),e._v(" "),_("li",[_("code",[e._v("no-cache")]),e._v(" 不使用强缓存，需要与服务器进行协商缓存验证。")]),e._v(" "),_("li",[_("code",[e._v("no-store")]),e._v(" 缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。")])]),e._v(" "),_("p",[_("strong",[e._v("过期")])]),e._v(" "),_("ul",[_("li",[_("code",[e._v("max-age=<seconds>")]),e._v(" 缓存存储的最大周期，超过这个周期被认为过期。")]),e._v(" "),_("li",[_("code",[e._v("s-maxage=<seconds>")]),e._v(" 设置共享缓存。会覆盖"),_("code",[e._v("max-age")]),e._v("和"),_("code",[e._v("expires")]),e._v(",私有缓存会忽略它")]),e._v(" "),_("li",[_("code",[e._v("max-stale[=<seconds>]")]),e._v(" 客户端愿意接收一个已经过期的资源，可以设置一个可选的秒数，表示响应不能已经过时超过该给定的时间。")]),e._v(" "),_("li",[_("code",[e._v("min-fresh=<seconds>")]),e._v(" 客户端希望在指定的时间内获取最新的响应")])]),e._v(" "),_("p",[_("strong",[e._v("重新验证和重新加载")])]),e._v(" "),_("ul",[_("li",[_("code",[e._v("must-revalidate")]),e._v(" 如页面过期，则去服务器进行获取。")]),e._v(" "),_("li",[_("code",[e._v("proxy-revalidate")]),e._v(" 与"),_("code",[e._v("must-revalidate")]),e._v(" 作用相同，但是用于共享缓存。")])]),e._v(" "),_("p",[_("strong",[e._v("其他")])]),e._v(" "),_("ul",[_("li",[_("code",[e._v("only-if-cached")]),e._v(" 不进行网络请求，完全只使用缓存。")]),e._v(" "),_("li",[_("code",[e._v("no-transform")]),e._v(" 不得对资源进行转换和转变。例如，不得对图像格式进行转换。")])]),e._v(" "),_("p",[e._v("协商缓存可以通过 "),_("code",[e._v("Last-Modified")]),e._v("/"),_("code",[e._v("If-Modified-Since")]),e._v("和"),_("code",[e._v("ETag")]),e._v("/"),_("code",[e._v("If-None-Match")]),e._v("这两对 Header 来控制。")]),e._v(" "),_("h3",{attrs:{id:"last-modified、if-modified-since"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#last-modified、if-modified-since"}},[e._v("#")]),e._v(" Last-Modified、If-Modified-Since")]),e._v(" "),_("p",[_("code",[e._v("Last-Modified")]),e._v("与"),_("code",[e._v("If-Modified-Since")]),e._v(" 的值都是 GMT 格式的时间字符串，代表的是文件的最后修改时间。")]),e._v(" "),_("ol",[_("li",[e._v("在服务器在响应请求时，会通过"),_("code",[e._v("Last-Modified")]),e._v("告诉浏览器资源的最后修改时间。")]),e._v(" "),_("li",[e._v("浏览器再次请求服务器的时候，请求头会包含"),_("code",[e._v("Last-Modified")]),e._v("字段，后面跟着在缓存中获得的最后修改时间。")]),e._v(" "),_("li",[e._v("服务端收到此请求头发现有"),_("code",[e._v("if-Modified-Since")]),e._v("，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可。如果已经修改，那么开始传输响应一个整体，服务器返回：200 OK")])]),e._v(" "),_("p",[e._v("但是在服务器上经常会出现这种情况，一个资源被修改了，但其实际内容根本没发生改变，会因为"),_("code",[e._v("Last-Modified")]),e._v("时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP/1.1 推出了"),_("code",[e._v("Etag")]),e._v("。Etag 优先级高于"),_("code",[e._v("Last-Modified")]),e._v("。")]),e._v(" "),_("h3",{attrs:{id:"etag、if-none-match"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#etag、if-none-match"}},[e._v("#")]),e._v(" Etag、If-None-Match")]),e._v(" "),_("p",[_("code",[e._v("Etag")]),e._v("都是服务器为每份资源生成的唯一标识，就像一个指纹，资源变化都会导致 ETag 变化，跟最后修改时间没有关系，"),_("code",[e._v("ETag")]),e._v("可以保证每一个资源是唯一的。在浏览器发起请求，浏览器的请求报文头会包含 "),_("code",[e._v("If-None-Match")]),e._v("  字段，其值为上次返回的"),_("code",[e._v("Etag")]),e._v("发送给服务器，服务器接收到次报文后发现 "),_("code",[e._v("If-None-Match")]),e._v(" 则与被请求资源的唯一标识进行对比。如果相同说明资源没有修改，则响应返 304，浏览器直接从缓存中获取数据信息。如果不同则说明资源被改动过，则响应整个资源内容，返回状态码 200。")]),e._v(" "),_("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),_("p",[e._v("通过前文，我们了解到 HTTP 缓存主要分强制缓存和协商缓存。强制缓存由 "),_("code",[e._v("Cache-Control")]),e._v("，"),_("code",[e._v("Exipres")]),e._v("（HTTP1.0）控制。浏览器直接读本地缓存，不会再跟服务器端交互，状态码 200。协商缓存由 "),_("code",[e._v("Last-Modified")]),e._v(" / "),_("code",[e._v("IfModified-Since")]),e._v("， "),_("code",[e._v("Etag")]),e._v(" /"),_("code",[e._v("If-None-Match")]),e._v("实现，每次请求需要让服务器判断一下资源是否更新过，从而决定浏览器是否使用缓存，如果是，则返回 304，否则重新完整响应。")]),e._v(" "),_("h4",{attrs:{id:"参考文章链接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考文章链接"}},[e._v("#")]),e._v(" 参考文章链接")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://juejin.cn/post/6947936223126093861",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端浏览器缓存知识梳理"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://mp.weixin.qq.com/s/y7u6OC7OKmXIoR_vZRC77g",target:"_blank",rel:"noopener noreferrer"}},[e._v("了解 HTTP 缓存吗？有关 HTTP 缓存的首部字段说一下 ？"),_("OutboundLink")],1),_("br"),e._v(" "),_("a",{attrs:{href:"https://github.com/lgwebdream/FE-Interview/issues/14",target:"_blank",rel:"noopener noreferrer"}},[e._v("说一下 Http 缓存策略，有什么区别，分别解决了什么问题"),_("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=t.exports}}]);